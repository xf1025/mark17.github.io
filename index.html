<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>17的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="不忘初心 砥砺前行">
<meta property="og:type" content="website">
<meta property="og:title" content="17的博客">
<meta property="og:url" content="https://xf1025.github.io/mark17.github.io/index.html/index.html">
<meta property="og:site_name" content="17的博客">
<meta property="og:description" content="不忘初心 砥砺前行">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="17的博客">
<meta name="twitter:description" content="不忘初心 砥砺前行">
  
    <link rel="alternate" href="/atom.xml" title="17的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/mark17.github.io/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/mark17.github.io/" id="logo">17的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/mark17.github.io/" id="subtitle">随手的笔记</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/mark17.github.io/">Home</a>
        
          <a class="main-nav-link" href="/mark17.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xf1025.github.io/mark17.github.io/index.html"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-“node-js到底是用来做什么的”" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mark17.github.io/2017/10/03/“node-js到底是用来做什么的”/" class="article-date">
  <time datetime="2017-10-03T13:45:24.000Z" itemprop="datePublished">2017-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mark17.github.io/2017/10/03/“node-js到底是用来做什么的”/">“node.js到底是用来做什么的”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-js的到底是用来做什么的"><a href="#Node-js的到底是用来做什么的" class="headerlink" title="Node.js的到底是用来做什么的"></a>Node.js的到底是用来做什么的</h1><p>在阐述之前我想放一个链接，这是国外的一个大神，对于node.js非常好的一篇介绍的文章,英文比较好的朋友可以直接去阅读，<strong>本文也很大程度上参考了这篇文章，也同时感谢知乎用户厂长对于本文的翻译！</strong>原文题目为<a href="https://www.sitepoint.com/node-js-is-the-new-black/" target="_blank" rel="external">Node.js is the New Black</a></p>
<p>#Node.js的简介<br>根据维基百科对于Node.js的介绍，我们可以知道一些基本关于Node.js的情况。Node.js是瑞安·达尔（Ryan Dahl）在2009年发明出来的一种一个能够在服务器端运行JavaScript，并且可以开放源代码，以及跨平台运行JavaScript的一种运行环境。<br>Node.js采用了Google公司的V8引擎。Node.js允许通过JavaScript和一系列模块来编写服务器端应用和网络相关的应用。核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。<br>Node.js主要用于编写像Web服务器一样的网络应用，这和PHP和Python是类似的。但是Node.js与其他语言最大的不同之处在于，PHP等语言是阻塞的（只有前一条命令执行完毕才会执行后面的命令），而Node.js是非阻塞的（多条命令可以同时被运行，通过回调函数得知命令已结束运行）。<br>Node.js是事件驱动的。开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。其他服务器端语言难以开发高并发应用，而且即使开发出来，性能也不尽人意。Node.js正是在这个前提下被创造出来。Node.js把JavaScript的易学易用和Unix网络编程的强大结合到了一起。<br>Node.js使用Google V8 JavaScript 引擎，因为</p>
<ul>
<li>V8是基于BSD许可证的开源软件</li>
<li>V8速度非常快</li>
<li>V8专注于网络功能，在HTTP、DNS、TCP等方面更加成熟</li>
</ul>
<p>Node.js已经有数十万模块，它们可以通过一个名为npm的管理器免费下载。Node.js开发社区主要有两个邮件列表、一个在freenode的名为#node.js的IRC频道。社区集中在<a href="http://nodeconf.com" target="_blank" rel="external">NodeConf</a>。</p>
<h1 id="杂叙"><a href="#杂叙" class="headerlink" title="杂叙"></a>杂叙</h1><p>在学习Web前端的朋友看来，Node.js是一个经常会听到而且无法回避的问题，然而国内的资料相对较少，国外的资料大多数是以英文为主要蓝本阐述的，所以友好度并不高，我结合最近查询到的资料，结合自己浅薄的见解，做出一点点介绍和综述，希望可以帮到大家。如有不正，多请斧正！</p>
<h4 id="1-Node-js到底是什么"><a href="#1-Node-js到底是什么" class="headerlink" title="1.  Node.js到底是什么"></a>1.  Node.js到底是什么</h4><p>Node.js在维基百科中就已经很明确的说明了，它是一个<strong>运行环境</strong>，并不是其他的什么比如软件库，简而言之，和C#所需要的编译环境一样，Node.js就是JavaScript的编译环境，它存在的目的就是为了让JavaScript可以和其他的后端语言一样能够在浏览器上运行，换种说法就是，可以让前端语言JavaScript在写完之后交给Node.js进行编译和解释，它的存在对于JavaScript有了质的飞跃，对于一个前端来说利用JavaScript就可以编译后台代码是一件多么爽飞天的事情。<br>简单的Node.js命令就是</p>
<p><code>#node hello.js</code></p>
<h4 id="2-V8引擎"><a href="#2-V8引擎" class="headerlink" title="2. V8引擎"></a>2. V8引擎</h4><p>我们都知道计算机处理器智能识别机器语言，而JavaScript是一门高级语言，计算机并不能直接读懂。所以我们需要所谓的引擎来将其转化成计算机所能理解的语言。v8引擎是由Google推出的，为其浏览器Chrome所设计的开源JavaScript引擎。得益于JIT，编译模式的改变与编译阶段的优化，JavaScript的性能得到了一个飞跃。其源代码是用c++写的，感除了对JavaScript性能的大幅提升，v8引擎也提供了“嵌入”的功能，使得开发者也可以在自己的c++程序中使用“嵌入”的v8引擎，从而高效地编译JavaScript，并加入c++的feature。要知道，作为一个底层得多的语言，c++可以实现的feature可要比JavaScript多得多。举例说明，JavaScript本身并没有read这么一个function。然而通过v8，我们可以将其绑定到一个用c++写的read callback上，从而通过JavaScript我们也可以直接加载文件了。<br>于是，借助于v8种种便利的功能，Node.js诞生了。</p>
<h4 id="3-数据的请求和处理（表述的不太准确望海涵）"><a href="#3-数据的请求和处理（表述的不太准确望海涵）" class="headerlink" title="3. 数据的请求和处理（表述的不太准确望海涵）"></a>3. 数据的请求和处理（<em>表述的不太准确望海涵</em>）</h4><p>首先我们要注意的是<strong>浏览器给网站发请求的过程一直没怎么变过</strong>。当浏览器给网站发了请求。服务器收到了请求，然后开始搜寻被请求的资源。如果有需要，服务器还会查询一下数据库，最后把响应结果传回浏览器。不过，在传统的web服务器中，每一个请求都会让服务器创建一个新的进程来处理这个请求。后来有了Ajax，我们就不用每次都请求一个完整的新页面了，取而代之的是，每次只请求需要的部分页面信息就可以了。这显然是一个进步。但是比如你要建一个类似微博的社交网站，导致的结果是你的好友会随时的推送新的状态，然后你的新鲜事会实时自动刷新。要达成这个需求，我们需要让用户一直与服务器保持一个有效连接。目前最简单的实现方法，就是让用户和服务器之间保持长轮训（long polling）。<br>HTTP请求不是持续的连接，你请求一次，服务器响应一次，然后就完了。长轮训是一种利用HTTP模拟持续连接的技巧。具体来说，只要页面载入了，不管你需不需要服务器给你响应信息，你都会给服务器发一个Ajax请求。这个请求不同于一般的Ajax请求，服务器不会直接给你返回信息，而是它要等着，直到服务器觉得该给你发信息了，它才会响应。比如，你的好友发了一条新鲜事，服务器就会把这个新鲜事当做响应发给你的浏览器，然后你的浏览器就刷新页面了。浏览器收到响应刷新完之后，再发送一条新的请求给服务器，这个请求依然不会立即被响应。于是就开始重复以上步骤。利用这个方法，可以让浏览器始终保持等待响应的状态。虽然以上过程依然只有非持续的HTTP参与，但是我们模拟出了一个看似持续的连接状态我们再看传统的服务器。每次一个新用户连到你的网站上，你的服务器就得开一个连接。每个连接都需要占一个进程，这些进程大部分时间都是闲着的（比如等着你好友发新鲜事，等好友发完才给用户响应信息。或者等着数据库返回查询结果什么的）。虽然这些进程闲着，但是照样占用内存。这意味着，如果用户连接数的增长到一定规模，你服务器没准就要耗光内存直接瘫了。这种情况怎么解决？解决方法就是刚才上边说的：非阻塞和事件驱动。这些概念在我们谈的这个情景里面其实没那么难理解。你把非阻塞的服务器想象成一个loop循环，这个loop会一直跑下去。一个新请求来了，这个loop就接了这个请求，把这个请求传给其他的进程（比如传给一个搞数据库查询的进程），然后响应一个回调（callback）。完事了这loop就接着跑，接其他的请求。这样下来。服务器就不会像之前那样傻等着数据库返回结果了。如果数据库把结果返回来了，loop就把结果传回用户的浏览器，接着继续跑。在这种方式下，你的服务器的进程就不会闲着等着。从而在理论上说，同一时刻的数据库查询数量，以及用户的请求数量就没有限制了。服务器只在用户那边有事件发生的时候才响应，这就是事件驱动。FriendFeed是用基于Python的非阻塞框架Tornado (知乎也用了这个框架) 来实现上面说的新鲜事功能的。不过，Node.js就比前者更妙了。Node.js的应用是通过javascript开发的，然后直接在Google的变态V8引擎上跑。<br>用了Node.js，你就不用担心用户端的请求会在服务器里跑了一段能够造成阻塞的代码了。因为javascript本身就是事件驱动的脚本语言。你回想一下，在给前端写javascript的时候，更多时候你都是在搞事件处理和回调函数。所以javascript本身就是给事件处理量身定制的语言。</p>
<h4 id="4-使用Node-js的优劣（很重要）"><a href="#4-使用Node-js的优劣（很重要）" class="headerlink" title="4. 使用Node.js的优劣（很重要）"></a>4. 使用Node.js的优劣（很重要）</h4><p>在使用Node.js的时候我们可以知道，Node.js解决了很多JavaScript的痛点。当然Node.js作为一个语言也有很多都缺陷。<br><strong>优势</strong></p>
<ul>
<li>采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。</li>
<li>Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。</li>
<li>Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>可靠性低。</p>
</li>
<li><p>单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。</p>
</li>
</ul>
<p>当然对于这些缺点也哟普很多解决办法：</p>
<ul>
<li>开启多个进程，每个进程绑定不同的端口，用反向代理服务器如 Nginx 做负载均衡，好处是我们可以借助强大的 Nginx 做一些过滤检查之类的操作，同时能够实现比较好的均衡策略，但坏处也是显而易见——我们引入了一个间接层。</li>
<li>多进程绑定在同一个端口侦听。在Node.js中，提供了进程间发送“文件句柄” 的功能。</li>
<li>一个进程负责监听、接收连接，然后把接收到的连接平均发送到子进程中去处理。</li>
</ul>
<h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h4><p>SON APIs——构建一个Rest/JSON API服务，Node.js可以充分发挥其非阻塞IO模型以及JavaScript对JSON的功能支持(如JSON.stringfy函数)单页面、多Ajax请求应用——如Gmail，前端有大量的异步请求，需要服务后端有极高的响应速度基于Node.js开发Unix命令行工具——Node.js可以大量生产子进程，并以流的方式输出，这使得它非常适合做Unix命令行工具流式数据——传统的Web应用，通常会将HTTP请求和响应看成是原子事件。而Node.js会充分利用流式数据这个特点，构建非常酷的应用。如实时文件上传系统transloadit准实时应用系统——如聊天系统、微博系统，但Javascript是有垃圾回收机制的，这就意味着，系统的响应时间是不平滑的(GC垃圾回收会导致系统这一时刻停止工作)。如果想要构建硬实时应用系统，Erlang是个不错的选择。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Node.js是一个对于前端工作者不可或缺的工具。尤其是对于JavaScript有着巨大的提升，现阶段Node.js的应用已经有了非常蓬勃的发展。对于Node.js的学习和熟练运用，必不可少！以上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xf1025.github.io/mark17.github.io/index.html/2017/10/03/“node-js到底是用来做什么的”/" data-id="cj8bnxltl0000f8vo13mzxi8p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mark17.github.io/tags/不忘初心-砥砺前行/">不忘初心 砥砺前行</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从URL的输入到页面的展示" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mark17.github.io/2017/10/03/从URL的输入到页面的展示/" class="article-date">
  <time datetime="2017-10-03T13:30:03.000Z" itemprop="datePublished">2017-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mark17.github.io/2017/10/03/从URL的输入到页面的展示/">从URL的输入到页面的展示</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="从URL的输入到页面的展示的发生内容"><a href="#从URL的输入到页面的展示的发生内容" class="headerlink" title="从URL的输入到页面的展示的发生内容"></a>从URL的输入到页面的展示的发生内容</h1><p>#####最近一直在思考从url到页面展示这个问题的具体答案，查询了相当多的资料，也看了看关于《图解HTTP》这本书，对于这个在前端界一直讨论不休的问题有了一些些自己的见解和观点，阐述出来，还请各位多多斧正不胜感谢。</p>
<h5 id="在我看来主要的发生时间有以下几件："><a href="#在我看来主要的发生时间有以下几件：" class="headerlink" title="在我看来主要的发生时间有以下几件："></a>在我看来主要的发生时间有以下几件：</h5><ol>
<li>URL的输入</li>
<li>DNS解析</li>
<li>TCP的连接</li>
<li>服务器处理请求和处理</li>
<li>浏览器处理和渲染</li>
</ol>
<hr>
<h1 id="一、URL的输入"><a href="#一、URL的输入" class="headerlink" title="一、URL的输入"></a>一、URL的输入</h1><p>在进行URL输入的阐述之前，我觉得有必要现对于URL有一个介绍和说明。<br>URL（Uniform Resource Locator），统一资源定位符，有时候也会被人俗称为网页，然而URL的真是身份就是网站网址，主要作用就是定位互联网上资源。一般来说URL的格式主要是</p>
<blockquote>
<p>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</p>
</blockquote>
<p>其中需要重点介绍的就是协议类型，一般有以下几种</p>
<ul>
<li>http (超文本传输协议)</li>
<li>https（超文本传输协议的安全版）</li>
<li>ftp（文件传输协议）</li>
<li>file</li>
</ul>
<hr>
<p>#二、 DNS的解析<br>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如下面这个百度网的地址<www.baidu.com>，其实不是百度网站真正意义上的地址,他只是百度网站的一种表现形式，实际上百度的的真正IP为119.75.217.109。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。<br>一般来说DNS的解析主要的步骤分为以下几种：</www.baidu.com></p>
<ol>
<li>在本地域名服务器中查询IP地址。</li>
<li>在本地的域名服务器中没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，进一步进行解析查找。</li>
<li>如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到真正的IP地址并把它缓存到本地，供下次查询使用。</li>
</ol>
<p>从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; baidu.com -&gt; www.baidu.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.baidu.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; baidu.com. -&gt; www.baidu.com.。</p>
<hr>
<h1 id="三、-TCP的连接"><a href="#三、-TCP的连接" class="headerlink" title="三、 TCP的连接"></a>三、 TCP的连接</h1><p>TCP连接的主要作用是为实现数据的可靠传输，TCP要在应用进程间建立传输连接。它是在两个传输用户之间建立一种逻辑联系，使得通信双方都确认对方为自己的传输连接端点。<br>根据所查询的资料介绍来看，对于TCP连接同样也分为三个部分：</p>
<ol>
<li>建立连接前，服务器端首先被动打开其熟知的端口，对端口进行侦听。</li>
<li>当客户端要和服务器端建立连接时，发起一个主动打开端口的请求（该端口一般为临时端口）。</li>
<li>然后进入三次握手的过程。</li>
</ol>
<hr>
<h1 id="四、-服务器的处理请求"><a href="#四、-服务器的处理请求" class="headerlink" title="四、 服务器的处理请求"></a>四、 服务器的处理请求</h1><p>一般来说，服务器的请求处理分为两个情况</p>
<ol>
<li>服务器响应请求，将数据返回给浏览器。数据可能是根据HTML协议组织的网页，里面包含页面的布局、文字。数据也可能是图片、脚本程序等。现在你可以用浏览器的“查看源代码”功能，感受一下服务器返回的是什么东东。如果资源路径指示的资源不存在，服务器就会返回著名的404错误。</li>
<li>如果服务器的请求返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，则会重新从前几个步骤再次获取。</li>
</ol>
<hr>
<h1 id="五、-浏览器的处理和渲染"><a href="#五、-浏览器的处理和渲染" class="headerlink" title="五、 浏览器的处理和渲染"></a>五、 浏览器的处理和渲染</h1><p>浏览器在收到了服务器发送过来的HTML、CSS、JavaScript以后开始进行处理和渲染，这个步骤是整个部分中最核心，也是最为复杂的部分。<br>在浏览器的解析和渲染中一般分为两个部分：</p>
<ol>
<li>HTML和CSS的处理与渲染<br>我们要知道浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</li>
<li>JS的处理和渲染<br>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</li>
</ol>
<hr>
<p>以上只是最基本的步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，<strong>TCP/IP、DNS、HTTP、HTML</strong>：每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。不是计算机专业的同学看了上面的解释完全不明白是很正常的，可能会问为什么要搞得那么复杂，但我保证这每一个步骤都经过深思熟虑和时间的考验。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出你难以想象的努力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xf1025.github.io/mark17.github.io/index.html/2017/10/03/从URL的输入到页面的展示/" data-id="cj8bnxltw0001f8vo7m98bmuq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mark17.github.io/tags/不忘初心-砥砺前行/">不忘初心 砥砺前行</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/mark17.github.io/tags/不忘初心-砥砺前行/">不忘初心 砥砺前行</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/mark17.github.io/tags/不忘初心-砥砺前行/" style="font-size: 10px;">不忘初心 砥砺前行</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/mark17.github.io/archives/2017/10/">十月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/mark17.github.io/2017/10/03/“node-js到底是用来做什么的”/">“node.js到底是用来做什么的”</a>
          </li>
        
          <li>
            <a href="/mark17.github.io/2017/10/03/从URL的输入到页面的展示/">从URL的输入到页面的展示</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mark17<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/mark17.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/mark17.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/mark17.github.io/fancybox/jquery.fancybox.css">
  <script src="/mark17.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/mark17.github.io/js/script.js"></script>

  </div>
</body>
</html>